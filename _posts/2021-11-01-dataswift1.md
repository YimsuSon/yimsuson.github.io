---
title: 14.ë°ì´í„° êµ¬ì¡° (siwft)
excerpt: Swift


#ìµœìƒìœ„ ì‚¬ì§„
header:
  image: /assets/images/foo-bar-identity.jpg
  teaser: /assets/images/foo-bar-identity-th.jpg

gallery:
  - url: /assets/images/unsplash-gallery-image-1.jpg
    image_path: assets/images/unsplash-gallery-image-1-th.jpg
    alt: "placeholder image 1"
  - url: /assets/images/unsplash-gallery-image-2.jpg
    image_path: assets/images/unsplash-gallery-image-2-th.jpg
    alt: "placeholder image 2"
  - url: /assets/images/unsplash-gallery-image-3.jpg
    image_path: assets/images/unsplash-gallery-image-3-th.jpg
    alt: "placeholder image 3"
    


 #ì‚¬ì´ë“œë°” ì„¤ì • 
sidebar:
  - title: "Role"
    nav: sidebar-sample

# í•´ë‹¹ ê¸€ ëª©ì°¨
toc: true
toc_sticky: true

toc_label: "Yimsu's Blog"
toc_icon: "cog"


## í…Œê·¸ì„¤ì •


categories:
  - Data structure

tags:
  - Data structure
  - "2021"
  - "2021.11"



---

### 1. Bubble Sort 

<br/>
<br/>


```swift

var a = [2,6,3,1]
print(a.count)






























func bubbleSort(_ array: inout [Int]) {
    // ìŠ¤ìº” ì‘ì—… ë°˜ë³µ
    for index1 in 0 ..< (array.count - 1) { // 0~2
        
        var isSwap = false
        
        // ìŠ¤ìº” ì‘ì—…(ì¸ì ‘ ì¸ë±ìŠ¤ ë¹„êµ ë° swap ë°˜ë³µ) : (íƒìƒ‰í•˜ë ¤ëŠ” ìš”ì†Œì˜ ê°¯ìˆ˜) - 1
        // => íƒìƒ‰í•˜ë ¤ëŠ” ìš”ì†Œì˜ ê°¯ìˆ˜ëŠ” ìŠ¤ìº” íšŸìˆ˜ì— ë”°ë¼ ì°¨ê°ë¨(ìŠ¤ìº” íšŸìˆ˜ë§Œí¼ ì •ë ¬ë˜ì–´ ìˆì„í…Œë‹ˆ)
        for index2 in 0 ..< ( (array.count - index1) - 1 ) {
            
            // ì•ì—ìˆ«ìê°€ í¬ë‹¤ë©´
            if array[index2] > array[index2 + 1] {
               //êµí™˜
               array.swapAt(index2, (index2 + 1))
                //êµí™˜ í–ˆë‹¤ëŠ”ê²ƒ í‘œì‹œ
                isSwap = true
            }
        }
        // êµí™˜ì´ ëë‚˜ë©´ ì¢…ë£Œ
        if isSwap == false { return }
    }
}



bubbleSort(&a)

// í•¨ìˆ˜ ë‚´ë¶€ì˜ íŒŒë¼ë¯¸í„°ëŠ” ê¸°ë³¸ì ìœ¼ë¡œ ìƒìˆ˜(let) ì´ê¸° ë•Œë¬¸ì— inout ìœ¼ë¡œ ì„ ì–¸í•´ì•¼ ë°”ê¿€ìˆ˜ ìˆë‹¤




```



### 2. Select sort

``` swift


var array = [4,6,1,3]

































func select(_ array : inout [Int] ) {
    for i in 0 ..< (array.count - 1) {
        var min = i
        for i2 in (i + 1) ..< array.count {
            if array[min] > array[i2] {
                min = i2
            }
        }
        array.swapAt(i, min)
    }
}




select(&array)





```


### 3. Insertion Sort 

``` swift



var array = [9,8,1,2]



func i (_ arr:inout[Int]){
    for i in 1..<arr.count{
        for i2 in stride(from: i, to: 0, by: -1){
            if arr[i2] < arr[i2-1]{
                arr.swapAt(i2, i2-1)
            } else {
                break
            }
        }
    }
}

i(&array)












func insert(_ array : inout [ Int ]) {
    for stand in 1 ..< array.count {
        for index in stride(from : stand , to : 0 , by: -1) {
            if array[index] < array[index - 1] {
                array.swapAt(index, index - 1 )
            } else {
                break
            }
        }
    }
}
insert(&array)



// ì„ íƒ < ë²„ë¸” < ì‚½ì… ì •ë ¬ ìˆœìœ¼ë¡œ ë¹ ë¥´ë‚˜ ê±°ì˜ ë¹„ìŠ·ë¹„ìŠ·í•˜ê²Œ ëŠë¦¼



```



### 4. ì¬ê·€ 

``` swift


// ì¼ë°˜ factorial êµ¬í˜„ ( 2! = 1x2 , 3! = 1x2x3 )
// for ë£¨í”„ê°€ 1ë²ˆìˆê¸° ë•Œë¬¸ì— ì‹œê°„ë³µì¡ë„ O(n)
// result ë³€ìˆ˜ 1ê°œ, ë£¨í”„ ìƒìˆ˜ n 1ê°œ ë¡œ 2ê°œì˜ ê³µê°„ë³µì¡ë„ O(1)
func f(_ num : Int) -> Int {
    var result = 1
    for n in 2...num {
        result *= n
    }
    return result
}

// ì¬ê·€ factorial êµ¬í˜„
// ë°˜ë³µë¬¸ì„ n-1ë²ˆ í˜¸ì¶œí•˜ê¸°ë•Œë¬¸ì— O(n-1)ì´ì§€ë§Œ ìƒìˆ˜ëŠ” ë‚ ë¦¬ê¸°ë•Œë¬¸ì— O(n)
// ì…ë ¥ nì— ë”°ë¼ (n-1) ë³€ìˆ˜ê°€ ìƒì„±ë˜ê¸° ë•Œë¬¸ì—  ê³µê°„ë³µì¡ë„ O(n)

func rf(_ num : Int) -> Int {
    if num <= 1 {
        return num
    } // íƒˆì¶œ ì¡°ê±´ì´ ì—†ëŠ” ê²½ìš° ë¬´í•œ ì¬ê·€ì— ë¹ ì§ˆìˆ˜ ìˆë‹¤
    
    return (num * rf(num - 1))
}

f(3)
rf(3)


```

### 5. Dynamic programming


``` swift


func fibo(_ n : Int) -> Int {
    var cache : [Int] = [0,1]
    for num in 2...n {
        cache.append(cache[num - 1] + cache[num - 2])
    }
    return cache[n]
}
fibo(4)


// ì¬ê·€ë¥¼ ì´ìš©í•œ êµ¬í˜„
func rfibo(_ n: Int) -> Int {
    if n <= 1 {return n}
    return rfibo(n - 1) + rfibo(n - 2)
}

rfibo(4)


// ì¬ê·€ì—ì„  0,1,2,3 ë²ˆì§¸ ê°’ê¹Œì§€ êµ¬í•œë’¤ ì €ì¥í•˜ê³  ì´ê±¸ ì´ìš©í•´ì„œ 2,3 indexì˜ ê°’ì„
// í™œìš©í•˜ëŠ” ê²ƒì´ê¸° ë•Œë¬¸ì— ì‹¤í–‰ì†ë„ê°€ ì¬ê·€ì— ë¹„í•˜ì—¬ ë¹ ë¥´ë‹¤



// ë™ì  ê³„íšë²•, ë¶„í•  ê³„íšë²• ê³µí†µì  : ë¬¸ì œë¥¼ ì˜ê²Œ ìª¼ê°œì„œ, ê°€ì¥ ì‘ì€ ë‹¨ìœ„ë¡œ ë¶„í• í•˜ì—¬ ë¬¸ì œë¥¼ í•´ê²°
// ë™ì  ê³„íšë²• ì°¨ì´ì  : - ì‘ì€ ë‹¨ìœ„ë¡œ ìª¼ê°œì§„ ë¬¸ì œë“¤ì€ ìƒìœ„ ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ë° ì¬ì‚¬ìš© ë¨
//                 - Memoization ê¸°ë²•ì„ ì‚¬ìš©í•¨
// ë¶„í•  ê³„íšë²• ì°¨ì´ì  : - ì‘ì€ ë‹¨ìœ„ë¡œ ìª¼ê°œì§„ ë¬¸ì œë“¤ì€ ìƒìœ„ ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ë° ì¬ì‚¬ìš©ë˜ì§€ ì•ŠìŒ
//                 - Memorization ê¸°ë²•ì„ ì‚¬ìš© ì•ˆí•¨




```


### 6. Quick Sort 


``` swift


var array = [7,10,3,9,1]


func quickSort(_ array: [Int]) -> [Int] {
    guard let first = array.first, array.count > 1 else {
        return array
    }
    
    let pivot = first
    let left = array.filter { $0 < pivot }
    let right = array.filter { $0 > pivot }
    
    return quickSort(left) + [pivot] + quickSort(right)
    
}
quickSort(array)


```


### 7. Merge Sort 


``` swift


var array = [6,5,3,1,8,7,2,4]






















func mergeSort(_ array : [Int]) -> [Int] {
    if array.count <= 1 { return array }
    let center = array.count / 2
    let left = Array(array[0..<center])
    let right = Array(array[center..<array.count])
    
    func merge(_ left:[Int], _ right:[Int]) -> [Int] {
        var left = left
        var right = right
        var result : [Int] = []
        
        while !left.isEmpty && !right.isEmpty {
            if left[0] < right[0] {
                result.append(left.removeFirst())
            } else {
                result.append(right.removeFirst())
            }
        }
        
        if !left.isEmpty {
            result.append(contentsOf:left)
        }
        
        if !right.isEmpty {
            result.append(contentsOf:right)
        }
        return result
    }
    
    return merge(mergeSort(left), mergeSort(right))
}


mergeSort(array)



```


### 8. ì™„ì „ íƒìƒ‰


``` swift 


func sequencial(_ array: [Int], num: Int) -> Bool {
    for element in array {
        if num == element {
            return true
        }
    }
    return false
}



```



### 9. Binary search 


``` swift




// ì¬ê·€ í•¨ìˆ˜ë¡œ êµ¬í˜„í•˜ê¸°
func binarySearch(_ array: [Int], num: Int) -> Bool {
    if array.count == 1 {
        return array[0] == num ? true : false
    }
    let mid = array.count / 2
    let range = array[mid] > num ? (0..<mid) : ((mid + 1)..<array.count)
    
    return binarySearch(Array(array[range]), num: num)
}
 

// ë°˜ë³µë¬¸ìœ¼ë¡œ êµ¬í˜„í•˜ê¸°
func binarySearch2(_ array: [Int], num: Int) -> Bool {
    var start = 0
    var end = (array.count - 1)
    
    while start <= end {
        let mid = (start + end) / 2
        
        if array[mid] == num { return true }
        if array[mid] > num {
            end = mid - 1
        } else {
            start = mid + 1
        }
    }
    return false
}


```



### 10. Graph - BFS


``` swift 

//BFS ë„ˆë¹„ìš°ì„ íƒìƒ‰
// ê°™ì€ ë ˆë²¨ì˜ ë…¸ë“œë¥¼ ìš°ì„ íƒìƒ‰í•œë‹¤

//ë„ˆë¹„ ìš°ì„  íƒìƒ‰ì€ ë³´í†µ ë‘ ê°œì˜ í(Queue)ë¡œ êµ¬í˜„
//ë°©ë¬¸ í•´ì•¼í•˜ëŠ” ë…¸ë“œë¥¼ ì €ì¥í•˜ëŠ” Queue(ì´í•˜,needVisitStack)
//ì´ë¯¸ ë°©ë¬¸í•œ ë…¸ë“œë¥¼ ì €ì¥í•˜ëŠ” Stack(ì´í•˜, visitedQueue)

// 1 íƒìƒ‰í•  ë…¸ë“œì˜ ë°ì´í„°ë¥¼ needVisitQueueì— ë„£ëŠ”ë‹¤
// 2 needVisitQueueì˜ ì²« ë²ˆì§¸ ê°’ì„ ì¶”ì¶œí•´ì„œ(FIFO), visitedQueueì— í•´ë‹¹ ê°’ì´ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸í•œë‹¤ (  visitedQueueì— ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ê°’ì´ ë‚˜ì˜¬ ë•Œê¹Œì§€ ë°˜ë³µ )
// 3 ì¶”ì¶œëœ ê°’ì´ visitedQueueì— ì¡´ì¬í•˜ì§€ ì•Šìœ¼ë©´, visitedQueueì— ì¶”ê°€í•œë‹¤



let graph: [String: [String]] = [
    "A" : ["B", "C"],
    "B" : ["A", "D", "E"],
    "C" : ["A", "F"],
    "D" : ["B"],
    "E" : ["B"],
    "F" : ["C"],
]


func BFS(graph: [String: [String]], start: String) -> [String] {
    var visitedQueue: [String] = []
    var needVisitQueue: [String] = [start]
    
    while !needVisitQueue.isEmpty {
        let node: String = needVisitQueue.removeFirst()
        if visitedQueue.contains(node) { continue }
        
        visitedQueue.append(node)
        needVisitQueue += graph[node] ?? []
    }
    
    return visitedQueue
}
 
BFS(graph: graph,start: "A")






```


### 11. DFS 

```swift 


// DFS

// ë°©ë¬¸ í•´ì•¼í•˜ëŠ” ë…¸ë“œë¥¼ ì €ì¥í•˜ëŠ” stack(needVisitStack)
// ì´ë¯¸ ë°©ë¬¸í•œ ë…¸ë“œë¥¼ ì €ì¥í•˜ëŠ” Queue(visitedQueue)

// 1 íƒìƒ‰í•  ë…¸ë“œì˜ ë°ì´í„°ë¥¼ needVisitStackì— ë„£ëŠ”ë‹¤
// 2 ì¶”ì¶œëœ ê°’ì´ visitedQueueì— ì¡´ì¬í•˜ì§€ ì•Šìœ¼ë©´ visitedQueueì— ì¶”ê°€í•œë‹¤
// 3 ì¶”ì¶œëœ ê°’ì— ì—°ê²°ëœ ê°„ì„ ë“¤ì„ ëª¨ë‘ needVisitStackì— ì¶”ê°€í•œë‹¤

let graph: [String: [String]] = [
    "A" : ["B", "C"],
    "B" : ["A", "D", "E"],
    "C" : ["A", "F"],
    "D" : ["B"],
    "E" : ["B"],
    "F" : ["C"],
]



func DFS(graph: [String: [String]], start: String) -> [String] {
    var visitedQueue: [String] = []
    var needVisitStack: [String] = [start]
    
    while !needVisitStack.isEmpty {
        let node: String = needVisitStack.removeLast()
        if visitedQueue.contains(node) { continue }
        
        visitedQueue.append(node)
       needVisitStack += graph[node] ?? []
    }
    
    return visitedQueue
}

DFS(graph: graph, start :"A")



```


### 12. Heap 

``` swift 

// Heap
// ë°ì´í„°ì—ì„œ ìµœëŒ€ê°’ê³¼ ìµœì†Œê°’ì„ ë¹ ë¥´ê²Œ ì°¾ê¸° ìœ„í•´ ê³ ì•ˆëœ "ì™„ì „ ì´ì§„ íŠ¸ë¦¬"
//  ìµœëŒ€ í™ì˜ Root NodeëŠ” í•­ìƒ ìµœëŒ€ ê°’
// ë¶€ëª¨ ë…¸ë“œì˜ ì¸ë±ìŠ¤ ë²ˆí˜¸ = ìì‹ ë…¸ë“œì˜ ì¸ë±ìŠ¤ ë²ˆí˜¸ / 2
// ì™¼ìª½ ìì‹ ë…¸ë“œì˜ ì¸ë±ìŠ¤ ë²ˆí˜¸ = ë¶€ëª¨ ë…¸ë“œ ì¸ë±ìŠ¤ ë²ˆí˜¸ * 2
// ì˜¤ë¥¸ìª½ ìì‹ ë…¸ë“œì˜ ì¸ë±ìŠ¤ ë²ˆí˜¸ = (ë¶€ëª¨ ë…¸ë“œ ì¸ë±ìŠ¤ ë²ˆí˜¸ * 2) + 1



//
//struct Heap<T: Comparable> {
//    var heap: Array<T> = []
//
//    init() { }
//    init(data: T) {
//        heap.append(data)       // 0ë²ˆ index ì±„ìš°ê¸°ìš©
//        heap.append(data)       // ì‹¤ì œ Root Node ì±„ìš°ê¸°
//    }
//}
//
//
////  insert(_:) : ë°ì´í„° ì‚½ì…í•˜ê¸°
//// â‘  ì™„ì „ ì´ì§„ íŠ¸ë¦¬ êµ¬ì¡°ì— ë§ì¶° ì¼ë‹¨ ì‚½ì…í•œë‹¤(ë°ì´í„° ë¹„êµ X)
////  â‘¡ ì‚½ì…ëœ ë°ì´í„°ì˜ í¬ê¸°ê°€ ë¶€ëª¨ë…¸ë“œì˜ ë°ì´í„°ë³´ë‹¤ ì‘ì„ ë•Œê¹Œì§€ swap í•´ì¤€ë‹¤ (ë°˜ë³µ ì‘ì—…)
//
//mutating func insert(_ data: T) {
//    if heap.count == 0 {
//        heap.append(data)
//        heap.append(data)
//        return
//    }
//
//    heap.append(data)
//
//    func isMoveUp(_ insertIndex: Int) -> Bool {
//        if insertIndex <= 1 {               // ë£¨íŠ¸ ë…¸ë“œì¼ ë•Œ
//            return false
//        }
//        let parentIndex: Int = insertIndex / 2
//        return heap[insertIndex] > heap[parentIndex] ? true : false
//    }
//
//    var insertIndex: Int = heap.count - 1
//    while isMoveUp(insertIndex) {
//        let parentIndex: Int = insertIndex / 2
//        heap.swapAt(insertIndex, parentIndex)
//        insertIndex = parentIndex
//    }
//}
//
//
//var heap = Heap.init(50)
//heap.insert(100)
//heap.insert(30)
//heap.insert(10)
//
//
//
//// pop() : ë°ì´í„° êº¼ë‚´ê¸°(ì‚­ì œí•˜ê¸°)
////  â‘  ê°€ì¥ í° ê°’ì¸ Root Nodeë¥¼ ì‚­ì œí•œë‹¤(Return ê°’)
////  â‘¡ ê°€ì¥ ë§ˆì§€ë§‰ì— ì¶”ê°€ëœ ë…¸ë“œ(ë°°ì—´ ë§ˆì§€ë§‰ ìš”ì†Œ)ë¥¼ Root Nodeë¡œ ì´ë™í•œë‹¤
//// â‘¢ ì´ë™ëœ Root Nodeì˜ ë°ì´í„°ê°€ ì™¼ìª½, ì˜¤ë¥¸ìª½ ìì‹ ë…¸ë“œì˜ ë°ì´í„°ë³´ë‹¤ í´ ë•Œê¹Œì§€,ìì‹ ë…¸ë“œ ì¤‘ í° ê°’ì„ ê°€ì§„ ë…¸ë“œì™€ swap í•´ì¤€ë‹¤ (ë°˜ë³µ ì‘ì—…)
//
//enum moveDownStatus { case none, left, right }
//
//mutating func pop() -> T? {
//    if heap.count <= 1 { return nil }
//
//    let returnData = heap[1]
//    heap.swapAt(1, heap.count - 1)
//    heap.removeLast()
//
//    func moveDown(_ poppedIndex: Int) -> moveDownStatus {
//        let leftChildIndex = (poppedIndex * 2)
//        let rightChildIndex = leftChildIndex + 1
//
//        // case 1. ëª¨ë“ (ì™¼ìª½) ìì‹ ë…¸ë“œê°€ ì—†ëŠ” ê²½ìš° (ì™„ì „ì´ì§„íŠ¸ë¦¬ëŠ” ì™¼ìª½ë¶€í„° ì±„ì›Œì§€ë¯€ë¡œ)
//        if leftChildIndex >= heap.count {
//            return .none
//        }
//
//        // case 2. ì™¼ìª½ ìì‹ ë…¸ë“œë§Œ ìˆëŠ” ê²½ìš°
//        if rightChildIndex >= heap.count {
//            return heap[leftChildIndex] > heap[poppedIndex] ? .left : .none
//        }
//
//        // case 3. ì™¼ìª½ & ì˜¤ë¥¸ìª½ ìì‹ ë…¸ë“œ ëª¨ë‘ ìˆëŠ” ê²½ìš°
//        // case 3-1. ìì‹ë“¤ì´ ìì‹ ë³´ë‹¤ ëª¨ë‘ ì‘ì€ ê²½ìš°
//        if (heap[leftChildIndex] < heap[poppedIndex]) && (heap[rightChildIndex] < heap[poppedIndex]) {
//            return .none
//        }
//
//        // case 3-2. ìì‹ë“¤ì´ ìì‹ ë³´ë‹¤ ëª¨ë‘ í° ê²½ìš° (ì™¼ìª½ê³¼ ì˜¤ë¥¸ìª½ ìì‹ ì¤‘ ë” í° ìì‹ ì„ ë³„)
//        if (heap[leftChildIndex] > heap[poppedIndex]) && (heap[rightChildIndex] > heap[poppedIndex]) {
//            return heap[leftChildIndex] > heap[rightChildIndex] ? .left : .right
//        }
//
//        // case 3-3. ì™¼ìª½ & ì˜¤ë¥¸ìª½ ì¤‘ í•œ ìì‹ë§Œ ìì‹ ë³´ë‹¤ í° ê²½ìš°
//        return heap[leftChildIndex] > heap[poppedIndex] ? .left : .right
//    }
//
//    var poppedIndex = 1
//    while true {
//        switch moveDown(poppedIndex) {
//        case .none:
//            return returnData
//        case .left:
//            let leftChildIndex = poppedIndex * 2
//            heap.swapAt(poppedIndex, leftChildIndex)
//            poppedIndex = leftChildIndex
//        case .right:
//            let rightChildIndex = (poppedIndex * 2) + 1
//            heap.swapAt(poppedIndex, rightChildIndex)
//            poppedIndex = rightChildIndex
//
//        }
//    }
//}
//
//
//
//var heap = Heap.init(30)
//heap.insert(20)
//heap.insert(18)
//heap.insert(9)
//heap.insert(6)
//heap.insert(50)
//
//print(heap)
//print("pop data == \(heap.pop()!)")
//print(heap)
//
//
//
//
//





struct Heap2<T> {
  var nodes: [T] = []
  let comparer: (T,T) -> Bool

  var isEmpty: Bool {
      return nodes.isEmpty
  }

  init(comparer: @escaping (T,T) -> Bool) {
      self.comparer = comparer
  }

  func peek() -> T? {
      return nodes.first
  }

  mutating func insert(_ element: T) {
      var index = nodes.count

    nodes.append(element) // ë§Œì•½ í˜„ì¬ íŠ¸ë¦¬ê°€ í¬í™” ìƒíƒœë¼ë©´, ìƒˆë¡œìš´ ë ˆë²¨ì— ë…¸ë“œë¥¼ ë„£ê³ , í¬í™” ìƒíƒœê°€ ì•„ë‹ˆë¼ë©´ í˜„ì¬ ë ˆë²¨ì— ë…¸ë“œë¥¼ ë¶™ì¸ë‹¤.

      while index > 0, !comparer(nodes[index],nodes[(index-1)/2]) {
          nodes.swapAt(index, (index-1)/2)
          index = (index-1)/2
      } // ë¶€ëª¨ ë…¸ë“œê°€ ìˆì„ ê²½ìš°, ë¶€ëª¨ë…¸ë“œì™€ì˜ ëŒ€ì†Œê´€ê³„ ê·œì¹™ì„ ë§Œì¡±í•˜ëŠ” ì§€ í™•ì¸í•©ë‹ˆë‹¤. ë§Œì¡±í•˜ì§€ ëª»í•˜ëŠ” ê²½ìš°, ë¶€ëª¨ ë…¸ë“œì™€ ìì‹ ë…¸ë“œë¥¼ êµí™˜í•œ ë’¤, ë¶€ëª¨ë…¸ë“œë¡œ ì´ë™í•œ ë’¤ ì´ ê³¼ì •ì„ ë°˜ë³µí•©ë‹ˆë‹¤. ë§Œì¡±í•˜ëŠ” ê²½ìš°ëŠ” ì‚½ì… ê³¼ì •ì„ ì¢…ë£Œí•©ë‹ˆë‹¤.
     
  }

  mutating func delete() -> T? {
      guard !nodes.isEmpty else {
          return nil
      }

      if nodes.count == 1 {
          return nodes.removeFirst()
      }

      let result = nodes.first
      nodes.swapAt(0, nodes.count-1) // í™ì˜ ë£¨íŠ¸ ë…¸ë“œì™€ í™ì˜ ë§ˆì§€ë§‰ ë ˆë²¨ì˜ ê°€ì¥ ì˜¤ë¥¸ìª½ ë…¸ë“œë¥¼ ë§ë°”ê¿‰ë‹ˆë‹¤.
      nodes.popLast() // í™ì˜ ë§ˆì§€ë§‰ ë ˆë²¨ì˜ ê°€ì¥ ì˜¤ë¥¸ìª½ ë…¸ë“œ(ì›ë˜ì˜ ë£¨íŠ¸ë…¸ë“œ)ë¥¼ ì œê±°í•©ë‹ˆë‹¤.

      var index = 0

      while index < nodes.count {
        // ë£¨íŠ¸ë…¸ë“œì—ì„œ ì‹œì‘í•´ì„œ ìì‹ ë…¸ë“œì™€ ëŒ€ì†Œ ê´€ê³„ë¥¼ ë¹„êµí•©ë‹ˆë‹¤. ì´ë•Œ ìì‹ì´ ë‘˜ì¼ ê²½ìš°ëŠ” ë¶€ëª¨ ë…¸ë“œì™€ ë°”ê¿¨ì„ ë•Œ ìì‹ ë…¸ë“œì™€ ëŒ€ì†Œê´€ê³„ ê·œì¹™ì„ ìœ ì§€í•  ìˆ˜ ìˆë„ë¡ ë°”ê¿”ì¤ë‹ˆë‹¤.
        
          let left = index * 2 + 1
          let right = left + 1

          if right < nodes.count {
            // ì˜¤ë¥¸ìª½ ë…¸ë“œê°€ ì¡´ì¬í•˜ëŠ” ê²½ìš°
              if comparer(nodes[left], nodes[right]),
                  !comparer(nodes[right], nodes[index]) {
                  nodes.swapAt(right, index)
                  index = right
              } else if !comparer(nodes[left], nodes[index]){
                  nodes.swapAt(left, index)
                  index = left
              } else {
                  break
              }
          } else if left < nodes.count {
            // ì™¼ìª½ ë…¸ë“œë§Œ ì¡´ì¬í•˜ëŠ” ê²½ìš°
              if !comparer(nodes[left], nodes[index]) {
                  nodes.swapAt(left, index)
                  index = left
              } else {
                  break
              }
          } else {
              break
          }
      }

      return result
  }
}

var heap: Heap2<Int> = Heap2 { $0 < $1 } // Max Heap ìƒì„±

heap.insert(20)
heap.insert(30)
heap.insert(18)
heap.insert(9)
heap.insert(6)
heap.insert(50)
print(heap)


``` 



### 13. ë‹¤ìµìŠ¤íŠ¸ë¼


``` swift 

// Dijkstra
// ìµœë‹¨ê²½ë¡œ ê²€ìƒ‰
// ìµœë‹¨ê²½ë¡œ ë¬¸ì œ íƒ€ì… 3ê°€ì§€
// 1. ë‹¨ì¼ì¶œë°œ - ë‹¨ì¼ë„ì°© íƒìƒ‰
// 2. ë‹¨ì¼ì¶œë°œ - ëª¨ë“ ë„ì°© íƒìƒ‰
// 3. ì „ì²´ìŒ ìµœë‹¨ê²½ë¡œ - ëª¨ë“  ìŒ ìµœë‹¨ê²½ë¡œ íƒìƒ‰


let graph: [String: [String: Int]] = [
    "A" : ["B": 9, "C" : 1, "D" : 15],
    "B" : ["E": 10],
    "C" : ["B": 5, "E" : 3],
    "D" : ["E": 10],
    "E" : ["F": 7],
    "F" : [:]
]
 

struct NodePriority: Comparable {
    static func < (lhs: NodePriority, rhs: NodePriority) -> Bool {
        lhs.priority > rhs.priority
    }
    var node: String = ""
    var priority: Int = 0
}


func dijkstra(graph: [String: [String: Int]], start: String) ->  [String: Int] {
    var distances: [String: Int] = [:]
    var priorityQueue = MaxHeap(NodePriority.init(node: start, priority: 0))
    
    for key in graph.keys {
        let value = key == start ? 0 : 2147483647
        distances.updateValue(value, forKey: key)
    }
    
    while !priorityQueue.isEmpty() {
        guard let popped = priorityQueue.pop() else { break }
        
        if distances[popped.node]! < popped.priority {
            continue
        }
        
        for (node, priority) in graph[popped.node]! {
            let distance = priority + popped.priority
            if distance < distances[node]! {
                distances[node] = distance
                priorityQueue.insert(NodePriority.init(node: node, priority: distance))
            }
        }
    }
    return distances
}
 



// 1.ë…¸ë“œë§ˆë‹¤ ì¸ì ‘í•œ ê°„ì„ ì„ ëª¨ë‘ ê²€ì‚¬í•˜ëŠ” ê³¼ì • = ğ‘‚(ğ¸)
// 2.ìš°ì„ ìˆœìœ„ íì— insert/pop í•˜ëŠ” ê³¼ì • = ğ‘‚(ğ‘™ğ‘œğ‘”ğ¸)
// ë‹¤ìµìŠ¤íŠ¸ë¼ ì‹œê°„ ë³µì¡ë„ = ğ‘‚(ğ¸ğ‘™ğ‘œğ‘”ğ¸)



```


### 14. Kruskal ì•Œê³ ë¦¬ì¦˜


``` swift 


// ì‹ ì¥íŠ¸ë¦¬ - ëª¨ë“  ë…¸ë“œê°€ ì—°ê²°ë˜ì–´ìˆìœ¼ë©°, ì‚¬ì´í´ ë°œìƒx
// ìµœì†Œ ì‹ ì¥íŠ¸ë¦¬ - ê°„ì„  ê°€ì¤‘ì¹˜ì˜ í•©ì´ ìµœì†Œì¸ ì‹ ì¥íŠ¸ë¦¬ (MST)

// ìµœì†Œ ì‹ ì¥íŠ¸ë¦¬ë¥¼ ì°¾ëŠ” ë°©ë²• 1. í¬ë£¨ìŠ¤ì¹¼, 2. í”„ë¦¼

// Union-find ì•Œê³ ë¦¬ì¦˜ - rank ë”•ì ¸ë„ˆë¦¬ë¥¼ ì¶”ê°€ë¡œ ë§Œë“¤ì–´ ì‚¬ì´í´ì´ ë°œìƒí•˜ëŠ”ê²ƒ ê²€ì‚¬
// Find - Parentë…¸ë“œë¥¼ í†µí•´ Root nodeë¥¼ ì°¾ê³  ë¹„êµí•´ì„œ ë…¸ë“œë“¤ì´ ì‚¬ì´í´ì´ ìƒê¸°ëŠ”ì§€ í™•ì¸
// Union - ì‚¬ì´í´ì´ ìƒê¸°ì§€ ì•Šìœ¼ë©´ í•©ì¹˜ëŠ” ì—°ì‚°




let vertices = ["A", "B", "C", "D"]
let edges = [
    (5,  "A", "B"),
    (1,  "A", "C"),
    (10, "A", "D"),
    (5,  "B", "A"),
    (3,  "B", "D"),
    (1,  "C", "A"),
    (8,  "C", "D"),
    (10, "D", "A"),
    (3,  "D", "B"),
    (8,  "D", "C"),
]



typealias edge = (Int, String, String)
 
func kruskal(vertices: [String], edges: [edge]) -> [edge] {
    var mst: [edge] = []
    
    var edges = edges.sorted { $0.0 < $1.0 }
    var rank: [String: Int] = [:]
    var parent: [String: String] = [:]
    
    for vertice in vertices {
        rank.updateValue(0, forKey: vertice)
        parent.updateValue(vertice, forKey: vertice)
    }
    
    func find(_ node: String) -> String {
        if node != parent[node]! {               // ë£¨íŠ¸ ë…¸ë“œ ì°¾ì•„ì•¼ë§Œ ì¬ê·€ íƒˆì¶œ
            parent[node] = find(parent[node]!)
        }
        return parent[node]!
    }
    
    func union(_ nodeV: String, _ nodeU: String) {
        let rankV = find(nodeV)
        let rankU = find(nodeU)
        
        if rankV > rankU {
            parent[rankU] = rankV
        } else {
            parent[nodeV] = nodeU
            if rankV == rankU {
                rank[nodeU]! += 1
            }
        }
    }
    
    while mst.count < (vertices.count - 1) {
        let node = edges.removeFirst()
        if find(node.1) != find(node.2) {
            union(node.1, node.2)
            mst.append(node)
        }
    }
    return mst
}

// ì‹œê°„ë³µì¡ë„ O(ElogE)



```



### 15. Prim ì•Œê³ ë¦¬ì¦˜ 


``` swift 


// í”„ë¦¼ì•Œê³ ë¦¬ì¦˜
// ê·¸ë˜í”„ë¥¼ ê°€ì§€ê³  ìµœì†Œì‹ ì¥íŠ¸ë¦¬ë¥¼ ì°¾ëŠ”ë°©ë²•

// 1 ì‹œì‘ë…¸ë“œë¥¼ ì •í•˜ê³  ì´ë¥¼ 'ì—°ê²°ëœ ë…¸ë“œ ì§‘í•©'ì— ì‚½ì…
// 2 Aì™€ ì—°ê²°ëœ ê°„ì„ ë“¤ì„ 'ê°„ì„  ë¦¬ìŠ¤íŠ¸'ì— ì‚½ì…
// 3 'ê°„ì„  ë¦¬ìŠ¤íŠ¸'ì— ì €ì¥ëœ ê°„ì„ ì¤‘ ê°€ì¥ ê°€ì¤‘ì¹˜ê°€ ì‘ì€ ê°„ì„ ì„ êº¼ë‚¸ë‹¤
// 4 ê°„ì„  ACì˜ ë„ì°©ì§€ Cê°€ ì—°ê²°ëœ ë…¸ë“œì§‘í•©ì— ìˆë‹¤ë©´ ì‹¸ì´í´ë°œìƒ,'ê°„ì„  ë¦¬ìŠ¤íŠ¸'ì—ì„œ ë‹¤ë¥¸ê°„ì„ ì„ êº¼ë‚¸ë‹¤
// 5 ê°„ì„  ACì˜ ë„ì°©ì§€ Cê°€ ì—°ê²°ëœ ë…¸ë“œì§‘í•©ì— ì—†ë‹¤ë©´ í•´ë‹¹ ê°„ì„ ì„ 'ì„ íƒ ë¦¬ìŠ¤íŠ¸'ì— ë„£ê³  í•´ë‹¹ ë…¸ë“œë¥¼
// 'ì—°ê²°ëœ ë…¸ë“œ ì§‘í•©'ì— ë„£ëŠ”ë‹¤




struct Edge: Comparable {
    var start: String = ""
    var dest: String = ""
    var weight: Int = 0
    
    init(_ start: String, _ dest: String, weight: Int) {
        self.start = start
        self.dest = dest
        self.weight = weight
    }
    
    static func < (lhs: Edge, rhs: Edge) -> Bool {
       lhs.weight < rhs.weight
    }
}
 
let vertices = ["A", "B", "C", "D"]
let edges: [Edge] = [
   .init("A", "B", weight: 5),
   .init("A", "C", weight: 1),
   .init("A", "D", weight: 10),
   .init("B", "A", weight: 5),
   .init("B", "D", weight: 3),
   .init("C", "A", weight: 1),
   .init("C", "D", weight: 8),
   .init("D", "A", weight: 10),
   .init("D", "B", weight: 3),
   .init("D", "C", weight: 8)
]



typealias edge = (Int, String, String)
 
func prim(start: String, vertices: [String], edges: [Edge]) -> [edge]? {
    var mst: [edge] = []                              // ì„ íƒ ë¦¬ìŠ¤íŠ¸
    var edgeList = MinHeap<Edge>()                    // ê°„ì„  ë¦¬ìŠ¤íŠ¸
    var connectedNode: Set<String> = []               // ì—°ê²°ëœ ë…¸ë“œ ì§‘í•©
    var adjacentEdges: [String: [Edge]] = [:]         // ëª¨ë“  ë…¸ë“œì— ì—°ê²°ëœ ëª¨ë“  ê°„ì„ ì„ ì €ì¥í•˜ëŠ” ë”•ì…”ë„ˆë¦¬
    
    for vertice in vertices {
        adjacentEdges.updateValue([], forKey: vertice)
    }
    for edge in edges {
        adjacentEdges[edge.start]?.append(edge)
    }
    
    guard let startEdges = adjacentEdges[start] else { return nil }

    connectedNode.insert(start)                       // ì²˜ìŒ ì„ íƒëœ ë…¸ë“œë¥¼ ì„ íƒ ë¦¬ìŠ¤íŠ¸ì— ì‚½ì…
    for edge in startEdges {                          // ì²˜ìŒ ì„ íƒëœ ë…¸ë“œì— ëŒ€í•œ ê°„ì„ ë“¤ì„ ê°„ì„  ë¦¬ìŠ¤íŠ¸ì— ì‚½ì…
        edgeList.insert(edge)
    }
    
    while mst.count < vertices.count {
        guard let poppedEdge = edgeList.pop() else { break }
        if connectedNode.contains(poppedEdge.dest) { continue }
        
        mst.append((poppedEdge.weight, poppedEdge.start, poppedEdge.dest))
        connectedNode.insert(poppedEdge.dest)
        
        guard let destEdges = adjacentEdges[poppedEdge.dest] else { return nil }
        for edge in destEdges {
            if !connectedNode.contains(edge.dest) {
                edgeList.insert(edge)
            }
        }
    }
    
    return mst
}












// MinHeap

struct MinHeap<T: Comparable> {
    var heap: Array<T> = []
    var isEmpty: Bool {
        return heap.count <= 1 ? true : false
    }

    init() { }
    init(_ data: T) {
        heap.append(data)       // 0ë²ˆ index ì±„ìš°ê¸°ìš©
        heap.append(data)       // ì‹¤ì œ Root Node ì±„ìš°ê¸°
    }

    mutating func insert(_ data: T) {
        if heap.isEmpty {
            heap.append(data)
            heap.append(data)
            return
        }
        heap.append(data)
        
        func isMoveUp(_ insertIndex: Int) -> Bool {
            if insertIndex <= 1 {               // ë£¨íŠ¸ ë…¸ë“œì¼ ë•Œ
                return false
            }
            let parentIndex: Int = insertIndex / 2
            return heap[insertIndex] < heap[parentIndex] ? true : false
        }
        
        var insertIndex: Int = heap.count - 1
        while isMoveUp(insertIndex) {
            let parentIndex: Int = insertIndex / 2
            heap.swapAt(insertIndex, parentIndex)
            insertIndex = parentIndex
        }
    }
    
    enum moveDownStatus { case left, right, none }
    
    mutating func pop() -> T? {
        if heap.count <= 1 { return nil }
        
        let returnData = heap[1]
        heap.swapAt(1, heap.count - 1)
        heap.removeLast()
        
        func moveDown(_ poppedIndex: Int) -> moveDownStatus {
            let leftChildIndex = (poppedIndex * 2)
            let rightCildIndex = leftChildIndex + 1
            
            // case1. ëª¨ë“ (ì™¼ìª½) ìì‹ ë…¸ë“œê°€ ì—†ëŠ” ê²½ìš° (ì™„ì „ì´ì§„íŠ¸ë¦¬ëŠ” ì™¼ìª½ë¶€í„° ì±„ì›Œì§€ë¯€ë¡œ)
            if leftChildIndex >= (heap.count) {
                return .none
            }
            
            // case2. ì™¼ìª½ ìì‹ ë…¸ë“œë§Œ ìˆëŠ” ê²½ìš°
            if rightCildIndex >= (heap.count) {
                return heap[leftChildIndex] < heap[poppedIndex] ? .left : .none
            }
            
            // case3. ì™¼ìª½ & ì˜¤ë¥¸ìª½ ìì‹ ë…¸ë“œ ëª¨ë‘ ìˆëŠ” ê²½ìš°
            // case 3-1. ìì‹ë“¤ì´ ìì‹ ë³´ë‹¤ ëª¨ë‘ ì‘ì€ ê²½ìš°
            if (heap[leftChildIndex] > heap[poppedIndex]) && (heap[rightCildIndex] > heap[poppedIndex]) {
                return .none
            }
            
            // case 3-2. ìì‹ë“¤ì´ ìì‹ ë³´ë‹¤ ëª¨ë‘ í° ê²½ìš° (ì™¼ìª½ê³¼ ì˜¤ë¥¸ìª½ ìì‹ ì¤‘ ë” í° ìì‹ ì„ ë³„)
            if (heap[leftChildIndex] < heap[poppedIndex]) && (heap[rightCildIndex] < heap[poppedIndex]) {
                return heap[leftChildIndex] < heap[rightCildIndex] ? .left : .right
            }
            
            // case 3-3. ì™¼ìª½ & ì˜¤ë¥¸ìª½ ì¤‘ í•œ ìì‹ë§Œ ìì‹ ë³´ë‹¤ í° ê²½ìš°
            return heap[leftChildIndex] < heap[poppedIndex] ? .left : .right
        }
        
        var poppedIndex = 1
        while true {
            switch moveDown(poppedIndex) {
            case .none:
                return returnData
            case .left:
                let leftChildIndex = poppedIndex * 2
                heap.swapAt(poppedIndex, leftChildIndex)
                poppedIndex = leftChildIndex
            case .right:
                let rightChildIndex = (poppedIndex * 2) + 1
                heap.swapAt(poppedIndex, rightChildIndex)
                poppedIndex = rightChildIndex
                
            }
        }
    }
}




```



### 16. Queue 


``` swift 

// Queue = FIFO


// enqueue = íì— ë°ì´í„°ë¥¼ ë„£ëŠ” ì‘ì—…
// dequeue = íì—ì„œ ë°ì´í„°ë¥¼ êº¼ë‚´ëŠ” ì‘ì—…
// front = ë°ì´í„°ë¥¼ êº¼ë‚´ëŠ” ìª½, ì¶œêµ¬
// rear = ë°ì´í„°ë¥¼ ë„£ëŠ” ìª½, ì…êµ¬

struct Queue<T> {
    private var queue: [T] = []
    
    public var count: Int {
        return queue.count
    }
    
    public var isEmpty: Bool {
        return queue.isEmpty
    }
    
    public mutating func enqueue(_ element: T) {
        queue.append(element)
    }
    
    public mutating func dequeue() -> T? {
        return isEmpty ? nil : queue.removeFirst()
    }
}

var myQueue = Queue<Int>()
myQueue.enqueue(10)
print(myQueue)
myQueue.dequeue()
print(myQueue)



// index ê°€ ìˆëŠ” í
struct Queue2<T> {
    private var queue: [T?] = []
    private var head: Int = 0
    
    public var count: Int {
        return queue.count
    }
    
    public var isEmpty: Bool {
        return queue.isEmpty
    }
    
    public mutating func enqueue(_ element: T) {
        queue.append(element)
    }
    
    public mutating func dequeue() -> T? {
        guard head <= queue.count, let element = queue[head] else { return nil }
        queue[head] = nil
        head += 1
        
        if head > 50 {
            queue.removeFirst(head)
            head = 0
        }
        return element
    }
}
 
var myQueue2 = Queue2<Int>()
myQueue2.enqueue(10)
myQueue2.enqueue(20)
myQueue2.enqueue(30)
print(myQueue2)

myQueue2.dequeue()
print(myQueue2)



// ì‹¤ìŠµ

struct q <T> {
    private var queue : [T] = []
    public var count : Int {
        return queue.count
    }
    
    public var isempty : Bool {
        return queue.isEmpty
    }
    
    public mutating func enqueue(_ element : T ){
        queue.append(element)
    }
    
    public mutating func dequeue() -> T? {
        return isempty ? nil : queue.removeFirst()
    }
    
}

var testQ = q<Int>()
testQ.enqueue(3)
testQ.enqueue(32)
testQ.enqueue(13)
print(testQ)



```


### 17. Stack


``` swift 


struct Stack <T> {
    var stack: [T] = []
    
    var count : Int {
        return stack.count
    }
    
    public var isEmpty: Bool {
        return stack.isEmpty
    }
    
    public mutating func push (_ element: T) {
        stack.append(element)
    }
    
    public mutating func pop() -> T? {
        return isEmpty ? nil : stack.popLast()
    }
    
}





var myStack = Stack<Int>()
myStack.push(10)
myStack.pop()



``` 


### 18. Linked List 

``` swift 

var greeting = "Hello, playground"

// ë°°ì—´ :  - ìƒˆë¡œìš´ ìš”ì†Œ ì‚½ì…ì´ ë¹ ë¦„ // í¬ê¸°ê°€ ê³ ì •ë˜ê³ , ì‚­ì œ ë° ê²€ìƒ‰ì´ ëŠë¦¼

// ì—°ê²°ë¦¬ìŠ¤íŠ¸ : - ë°ì´í„° ì‚½ì… ë° ì‚­ì œ ì†ë„ê°€ ë¹ ë¦„ // ê²€ìƒ‰ì´ ëŠë¦¬ë©° ì €ì¥ê³µê°„ íš¨ìœ¨ì´ ë‚®ìŒ


class Node<T> {
    var data: T? // Nodeì˜ ê°’
    var next: Node? // ë‹¤ìŒ Nodeì˜ ì£¼ì†Œ
    
    init(data: T?, next:Node? = nil) {
        self.data = data
        self.next = next
    }
}


class LinkedList<T:Equatable> {
    private var head : Node<T>? // ì²«ë…¸ë“œëŠ” ì—†ìœ¼ë¯€ë¡œ ì˜µì…”ë„
    
    
    func append(data: T?) {
        
        // ë…¸ë“œê°€ ì—†ì„ë•Œ headê°€ ì²«ë…¸ë“œë¥¼ ê°€ë¦¬í‚¨ë‹¤
        if head == nil {
            head = Node(data:data)
            return
        }
        
        // ê·¸ë ‡ì§€ ì•Šë‹¤ë©´ ë…¸ë“œì˜ ë§ˆì§€ë§‰ì— ìƒˆë¡œìš´ ë…¸ë“œë¥¼ ì¶”ê°€í•œë‹¤
        var node = head
        while node?.next != nil {
            // ê°€ì¥ ë§ˆì§€ë§‰ ë…¸ë“œë¡œ ì ‘ê·¼í•˜ê²Œí•œë‹¤
            node = node?.next
        }
        
        // ë§ˆì§€ë§‰ ë…¸ë“œì— ë„ì°©í•œ nodeì˜ nextì— ìƒˆë¡œìš´ ë…¸ë“œë¥¼ ì¶”ê°€í•œë‹¤
        node?.next = Node(data:data)
        
    }
    
    
    

    func insert(data: T?, at index : Int) {
        
        // ë…¸ë“œê°€ ì—†ì„ë•Œ headê°€ ì²«ë…¸ë“œë¥¼ ê°€ë¦¬í‚¨ë‹¤
        if head == nil {
            head = Node(data:data)
            return
        }
        
        // ê·¸ë ‡ì§€ ì•Šë‹¤ë©´ ë…¸ë“œì˜ ë§ˆì§€ë§‰ì— ìƒˆë¡œìš´ ë…¸ë“œë¥¼ ì¶”ê°€í•œë‹¤
        var node = head
        for _ in 0..<(index - 1 ){
            if node?.next == nil { break }
            node = node?.next
        }
        
        // ë‹¤ìŒ ë‹¤ìŒ ë…¸ë“œë¥¼ ì¶”ê°€í•œë‹¤
        let nextNode = node?.next
        node?.next = Node(data:data)
        node?.next?.next = nextNode
        
        
        while node != nil {
            // ì •ìƒí†µê³¼í•˜ëŠ”ì§€ í™•ì¸ í”„ë¦°íŠ¸
            //print("index:", index )
            print("index:", index ,"node:", node?.data ?? "x")
            node = node?.next
        }
    }


    func removeLast() {
        if head == nil {return}
        
        // ë§Œì•½ í˜„ì¬ head ê°€ nilì´ë©´ ë‹¤ìŒ ë…¸ë“œëŠ” ì—†ìœ¼ë¯€ë¡œ nil
        if head?.next == nil {
            head = nil
            return
        }
        
        // ë‹¤ìŒ headë¥¼ í˜„ì¬ë…¸ë“œë¡œ ê°€ì ¸ì˜¨ë‹¤
        var node = head
        while node?.next?.next != nil {
            node = node?.next
        }
        node?.next = node?.next?.next
    }

    func searchNode(from data : T?) -> Node<T>? {
        if head == nil { return nil }
        var node = head
        while node?.next != nil {
            if node?.data == data {break; }
            node = node?.next
        }
        return node
    }

}


let linkedList = LinkedList<Int>()
linkedList.insert(data: 1, at: 0)
linkedList.insert(data: 2, at: 1)
//linkedList.insert(data: 3, at: 2)





```