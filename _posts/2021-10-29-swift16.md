---
title: 16.프로그래머스 lv1 - 시저 암호 (siwft)
excerpt: Swift


#최상위 사진
header:
  image: /assets/images/foo-bar-identity.jpg
  teaser: /assets/images/foo-bar-identity-th.jpg

gallery:
  - url: /assets/images/unsplash-gallery-image-1.jpg
    image_path: assets/images/unsplash-gallery-image-1-th.jpg
    alt: "placeholder image 1"
  - url: /assets/images/unsplash-gallery-image-2.jpg
    image_path: assets/images/unsplash-gallery-image-2-th.jpg
    alt: "placeholder image 2"
  - url: /assets/images/unsplash-gallery-image-3.jpg
    image_path: assets/images/unsplash-gallery-image-3-th.jpg
    alt: "placeholder image 3"
    


 #사이드바 설정 
sidebar:
  - title: "Role"
    nav: sidebar-sample

# 해당 글 목차
toc: true
toc_sticky: true

toc_label: "Yimsu's Blog"
toc_icon: "cog"


## 테그설정

categories:
  - Swift

tags:
  - Swift
  - "2021"
  - "2021.10"



---

### 16. 프로그래머스 lv1 - 시저 암호 (siwft)

<br/>
<br/>


```swift



//유니코드 스칼라 개념

// String -> Unicode
var ccchar:String = "A"
UnicodeScalar(ccchar)?.value //65 = UInt32


// Int - > Unicode
let nnnum = 65
if let nnnum = UnicodeScalar(nnnum){
    print(nnnum)//A
}

// 아스키코드값 추출
let ssstr = "ab AB"
for iindex in ssstr.utf16 {
    print(iindex)// 97 98 32 65 66
}









//초성(19) ‘ㄱ’, ‘ㄲ’, ‘ㄴ’, ‘ㄷ’, ‘ㄸ’, ‘ㄹ’, ‘ㅁ’, ‘ㅂ’, ‘ㅃ’, ‘ㅅ’, ‘ㅆ’, ‘ㅇ’, ‘ㅈ’, ‘ㅉ’, ‘ㅊ’, ‘ㅋ’, ‘ㅌ’, ‘ㅍ’, ‘ㅎ’
//중성(21) ‘ㅏ’, ‘ㅐ’, ‘ㅑ’, ‘ㅒ’, ‘ㅓ’, ‘ㅔ’, ‘ㅕ’, ‘ㅖ’, ‘ㅗ’, ‘ㅘ’, ‘ㅙ’, ‘ㅚ’, ‘ㅛ’, ‘ㅜ’, ‘ㅝ’, ‘ㅞ’, ‘ㅟ’, ‘ㅠ’, ‘ㅡ’, ‘ㅢ’, ‘ㅣ’
//종성(28) 없음, ‘ㄱ’, ‘ㄲ’, ‘ㄳ’, ‘ㄴ’, ‘ㄵ’, ‘ㄶ’, ‘ㄷ’, ‘ㄹ’, ‘ㄺ’, ‘ㄻ’, ‘ㄼ’, ‘ㄽ’, ‘ㄾ’, ‘ㄿ’, ‘ㅀ’, ‘ㅁ’, ‘ㅂ’, ‘ㅄ’, ‘ㅅ’, ‘ㅆ’, ‘ㅇ’, ‘ㅈ’, ‘ㅊ’, ‘ㅋ’, ‘ㅌ’, ‘ㅍ’, ‘ㅎ’

//‘가’부터 ‘힣’ 까지입니다. (0xAC00 ~ 0xDCAF)
// 한글코드의 값 =  (초성 순서 * 21 * 28) + (중성 순서 * 28) + 종성 순서 + 0xAC00
// 첫 글자인 ‘가’의 경우, 초성 1번째, 중성 1번째, 종성 1번째입니다.
// (0 * 21 * 28) + (0 * 28) + 0 = 0
// 0xAC00 부터 0번째 뒤에 있는 문자

// 0xAC01과 0xAC02는 '각''갂'


// '나' ‘ㄴ’은 세 번째 초성이며 중성, 종성은 첫 번째이므로
// (2 * 21 * 28) + (0 * 28) + 0 = 1176
// 즉, ‘가’로부터 1176번째 뒤에 있는 값입니다.

// 따라서 ‘나’ 코드값은 0xAC00(16진수) + 1176(10진수)
// = 44032(10) + 1176(10)
// = 45208(10)
// = 0xB098(16)








// 한글 아스키코드 변환
var ccchar2 = "핳"
let ccccc = UnicodeScalar(ccchar2)?.value //55203 UInt32 ( 옵셔널적용되어리턴된다 )
let ccccc2 = UnicodeScalar(ccchar2)//55203  Unicode.Scalar?


let Cfirst = UnicodeScalar("B").value // Cfirst: UInt32 ( 인스턴스를 거치지 않을경우 바로 UInt32로 리턴 )
let Cfirst22 = UnicodeScalar("B") // Cfirst22: UnicodeScalar


// UnicodeScalar("A").value -> String 또는  인스턴스를 UInt32로 변경

// .unicodeScalars -> String를 String.UnicodeScalarView 타입으로 변경 -> 클로저로 옵셔널 인트로 변환이 필요







//unicodScalar를 커스텀포멧으로 print하기
let ppa = "학"

//ww: String.UnicodeScalarView
let ww = ppa.unicodeScalars
print(ww)

// ww2: String.UnicodeScalarView.Index
let ww2 = ppa.unicodeScalars.startIndex
print(ww2)

// ppc: UInt32
let ppc = ppa.unicodeScalars[ppa.unicodeScalars.startIndex].value
print(String(format:"0x%x", ppc))
print("코드 수: \(ppa.unicodeScalars.count)")








// 각각의 자모 인덱스로 분리
// 초성의 인덱스 : ((X - 0xAC00) / 28) / 21
let x = (ppc - 0xAC00) / 28 / 21
// 중성의 인덱스 : 중성 = ((X - 0xAC00) / 28) % 21
let y = ((ppc - 0xAC00) / 28) % 21 // 중성 인덱스 추출
//종성의 인덱스 : (X - 0xAC00) % 28
let zzz = (ppc - 0xAC00) % 28 // 종성 인덱스 추출

// 각각의 자모 인덱스로부터 자모 코드값 생성
//초성문자코드 = 0x1100 + 초성인덱스
let i = UnicodeScalar(0x1100 + x) // 0x1100 -> 초성 'ㄱ'
//중성문자코드 = 0x1161 + 중성인덱스
let j = UnicodeScalar(0x1161 + y) // 0x1161 -> 중성 'ㅏ'
// 종성문자코드 = 0x11A8 - 1 + 종성인덱스 // (종성이 없는 경우, 1을 뺌)
let k = UnicodeScalar(0x11a6 - 1 + zzz) // 0x11A6 -> 종성 {받침없음}

print("분해된 자모: \(i), \(j), \(k)")


let compositedString = "\u{1112}\u{1161}\u{11A8}"
print("자모코드를 합성한 문자열: \(compositedString)")

print(ppa == compositedString)









var num = 1
var aa : Character = "a"


// UInt8(Cahracter) + UInt8 이되야지 UInt32(String) + UInt8이되면 오류발생
let numberrr = aa.asciiValue! + UInt8(num)


let Cfirst = UnicodeScalar("B").value
let Clast = UnicodeScalar("Z").value
let Ufirst = UnicodeScalar("a").value
let Ulast = UnicodeScalar("z").value


//이동한 거리  = ( 문자인덱스  - "A"의 아스키인덱스 + index숫자)
(Int(Cfirst) - 65 + num)

// 이동한문자의 인덱스 =  ( 문자인덱스 - "A"의 아스키인덱스 + index숫자  ) % 알파벳 26글자 + "A의 아스키인덱스
let ttt = (Int(Cfirst)  - 65 + num) % 26 + 65
String(UnicodeScalar(ttt)!)


// ASCI 코드  a = 97 , z = 122
// String 은 문자열 , Character는 문자(UInt8)
// Int 양수,음수 저장, UInt 양수 저장



var s = "a B"
var n = 1

s.utf8

// aaa: String.UTF8View 타입
let aaa = s.utf8





func solution (_ s: String , _ n : Int ) -> String {
    return s.utf8.map {
        var number = Int($0)
        switch number {
        case 65 ... 96:
            number = ( number - 65 + n ) % 26 + 65
        case 97 ... 122:
            number = ( number - 97 + n ) % 26 + 97
        default:
            break
        }
        return String(UnicodeScalar(number)!)
    }.joined()
}



solution(s,n)



func solution2(_ s:String, _ n:Int) -> String {
    
    let answer = s.utf8.map { (codeInt) -> String in
        var number = Int(codeInt)
        
        if ( 65 ... 90 ).contains(number) {
            number = (number - 65 + n) % 26 + 65
        } else if ( 97 ... 122).contains(number){
            number = (number - 97 + n ) % 26 + 97
        }
        return String(UnicodeScalar(number)!)
    }
    
    return answer.joined()
}


solution2(s,n)











```