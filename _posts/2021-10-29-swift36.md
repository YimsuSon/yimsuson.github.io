---
title: 36.프로그래머스 lv2 - 프린터 (siwft)
excerpt: Swift


#최상위 사진
header:
  image: /assets/images/foo-bar-identity.jpg
  teaser: /assets/images/foo-bar-identity-th.jpg

gallery:
  - url: /assets/images/unsplash-gallery-image-1.jpg
    image_path: assets/images/unsplash-gallery-image-1-th.jpg
    alt: "placeholder image 1"
  - url: /assets/images/unsplash-gallery-image-2.jpg
    image_path: assets/images/unsplash-gallery-image-2-th.jpg
    alt: "placeholder image 2"
  - url: /assets/images/unsplash-gallery-image-3.jpg
    image_path: assets/images/unsplash-gallery-image-3-th.jpg
    alt: "placeholder image 3"
    


 #사이드바 설정 
sidebar:
  - title: "Role"
    nav: sidebar-sample

# 해당 글 목차
toc: true
toc_sticky: true

toc_label: "Yimsu's Blog"
toc_icon: "cog"


## 테그설정

categories:
  - Swift

tags:
  - Swift
  - "2021"
  - "2021.10"



---

### 36.프로그래머스 lv2 - 프린터 (siwft)

<br/>
<br/>


```swift

var priorities = [2, 1, 3, 2]
var location = 2



func solution(_ priorities:[Int], _ location:Int) -> Int {
    return 0
}












var a = priorities.enumerated()

let doc = priorities.removeFirst()
doc

//1. 주어진 배열을 먼저 index값을 포함하여 이중배열로 만든다.
//2. 2차원 배열에 값이 없을때 까지 순회를 돈다.

//3. 2차원 배열의 가장 첫번째 값을 꺼낸다. (Dequeue = 큐에서 데이터를 빼내는 동작)
//4. 2차원 배열의 우선순위 값만 다시 배열로 만든다.

//5. 우선순위 배열의 가장 큰 값을 꺼낸다.
//6. POP한 우선순위와 우선순위배열의 가장 큰값과 비교하여 POP, 크다면 출력대기열(result_에 추가, 아니라면 2차원배열(indexingArray)의 가장뒤쪽으로 보낸다 (Enqueue = 큐에 데이터를 넣는 동작)

//7. 1 ~ 6 과정을 이중배열이 없을때 까지 반복
//8.  index에 +1후 결과배열을 순회하여 index값과 location을 비교하여 같은경우 값을 출력해주면 된다.


func solution2(_ priorities:[Int], _ location:Int) -> Int {
    var indexingArray = [[Int]]() //2차원배열
    var result = [[Int]]()

    
    
    // 2차원 배열에 인덱스와 우선순위로 저장
    for (i, p) in priorities.enumerated() {
        indexingArray.append([i, p])
    }
    print(indexingArray) // enumerated는 set으로 저장하여 중복되는 2는 저장하지 않는듯
    
    
    
    
    // 조건이 만족하지 않으면 반복종료
    // indexingArray가 비어있을때까지 반복
    while indexingArray.isEmpty == false {
        
        // 대기열 맨 앞부터 꺼냄 ( Dequeue )
        let doc = indexingArray.removeFirst()
        //print(doc)
        //print(indexingArray)
        
        // 남은 대기열의 최우선순위 탐색
        var pri = 0
        for el in indexingArray {
            
            // 이전 property 값이 property의 값이 작다면 다음값으로 우선순위 갱신 ( 큰값이 먼저출력 )
            if pri < el[1] {
                pri = el[1] // el[0]은 인덱스
            }
        }

        // Eenque
        // 현재문서의 우선순위보다 중요도 높은 문서 없으면
        if doc[1] >= pri {
            //doc[0]은 인덱스
            
            // 출력 대기열에 추가
            result.append(doc)
        } else {
            
            // 아니면 대기열 맨뒤로 추가
            indexingArray.append(doc)
        }
    }

    
    
    // 출력대기열의 앞부터 요청한 문서의 순서 탐색
    var count = 0
    while result.isEmpty == false {
        count += 1

        let first = result.removeFirst()
        if (first[0] == location){
            break
        }
    }

    return count
}


solution2(priorities, location)















var aa = priorities.count
print(a)
priorities.contains(2)
priorities[0]

if priorities.contains(where: { $0 > priorities[0] }) {
    
}
    
    

func solution3(_ priorities:[Int], _ location:Int) -> Int {
    var cPriorities = priorities
    var targetIndex = location
    var seq = 0

    while cPriorities.count > 0 {
        // 만약 앞의 pri 가 첫번째 인덱스의 값 보다 크다면
        if cPriorities.contains(where: { $0 > cPriorities[0] }) {
        
            
            let first = cPriorities.removeFirst()
            
            cPriorities.append(first)
            targetIndex = targetIndex - 1 < 0 ? cPriorities.count - 1 : targetIndex - 1
            
        } else {
            // location이 0 이라면
            if(targetIndex == 0) {
                return priorities.count - cPriorities.count + 1
            }
            
            // 첫번째 값을 제거
            cPriorities.removeFirst()
            // location 을 -1 해준다
            targetIndex = targetIndex - 1
        }
    }

    return 0
}



```